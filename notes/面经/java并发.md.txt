# 线程安全

## 分类

**1. 不可变：**永远也不会改变，根本不存在线程安全问题。

- 自定义不可变对象：这个类是 final 的保证不能被扩展，把所有可能影响对象状态的字段都声明为 fianl 的，不提供任何会修改对象状态的方法，把所有的域声明为 private 的（避免客户端访问引用的可变域，保证对象能被正确的创建出来（在构造方法内不会有 this 引用逃逸）
- Jdk 中不可变对象：String、Long/Double 等包装类、BigInteger、BigDecimal 等大数据类型。AtomicInteger 和 AtomicLong 不是不可变对象

**2. 绝对线程安全**

**3. 相对线程安全：**Vector、HashTable、Collections.synchronizedCollection()

**4. 线程兼容：**对象本身并非线程安全，但是可以通过外部调用的同步保证线程安全：ArrayList、HashMap 等大部分类

**5. 线程对立：**调用端无论是否采取同步措施都不是线程安全的 System.setIn 和 System.setOut

## 实现方法

**1. 互斥 / 阻塞同步（悲观锁）**

**synchronized：**编译后在同步代码段的前后加上 monitorenter、monitorexit 两个指令；对同一线程来说是可重入的。因为 java 线程是映射到操作系统的原生线程之上的，阻塞或唤醒一个线程都需要从用户态切换到核心态，状态转换的时间可能比执行同步代码的时间还要长，所以 synchronized 是一个重量级的操作。
**ReentrantLock( 重入锁 )：**也是一个重量级的操作，在语义上与 synchronized 相同，但是可以进行更精细的控制：等待可中断（可以尝试获取锁）、公平锁（当多个线程都等待同一个锁时必须按照时间顺序获得锁）、锁绑定多个条件（可以同时绑定多个 Condition 对象）

**2. 非阻塞同步（乐观锁）**

先进性操作，如果没有其他线程争用共享数据就操作成功了，如果有就尝产生了冲突，然后在采取其他措施补偿（最常见的就是不断尝试，直到成功）

CAS 指令，例如 AtomicInteger.incrementAndGet() 方法的原子性

**3. 无同步方案**

可重入代码：不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入、不调用非可重入的方法。

## this 引用逃逸

是指在构造函数返回之前其他线程就持有该对象的引用。通常发生在以内部类的形式在构造函数中启动一个线程或者注册监听器。

```java
public class ThisEscape {
    public ThisEscape() {
        new Thread(new EscapeRunnable()).start();
    }
    private class EscapeRunnable implements Runnable {
        @Override
        public void run() {
            // 通过 ThisEscape.this 就可以引用外围类对象
            // 但是此时外围类对象可能还没有构造完成
        }
    }
}
```

改进：可以在构造方法中创建一个线程但是不要启动它。所以可以创建一个 private 的构造方法，然后创建一个工厂方法。

# Java 内存模型

Java 内存模型规定和指引 Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java 内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

*   线程内的代码能够按先后顺序执行，这被称为程序次序规则。
*   对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
*   前一个对 volatile 的写操作在后一个 volatile 的读操作之前，也叫 volatile 变量规则。
*   一个线程内的任何操作必需在这个线程的 start() 调用之后，也叫作线程启动规则。
*   一个线程的所有操作都会在线程终止之前，线程终止规则。
*   一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
*   可传递性
